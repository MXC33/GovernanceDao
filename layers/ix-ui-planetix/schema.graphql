directive @cacheControl(maxAge: Int, scope: CacheControlScope, inheritMaxAge: Boolean) on FIELD_DEFINITION | OBJECT | INTERFACE | UNION

"""Exposes a URL that specifies the behavior of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behavior of this scalar."""
  url: String!
) on SCALAR

type Attribute {
  value: String
  traitType: String
}

enum CacheControlScope {
  PUBLIC
  PRIVATE
}

type Contract {
  address: String
}

type CorporationCapacity {
  name: String!
  capacity: Int!
}

input CredentialsInput {
  playerId: Int!
  walletAddress: String!
}

type DailyTickets {
  ticketId: Int!
  minEntriesPerWallet: Int!
  maxEntriesPerWallet: Int!
  maxTotalEntries: Int!
  startTime: Int!
  duration: Int!
}

type GravityGradeSaleInfo {
  saleId: Int
  tokenId: Int
  salePrice: Int
  totalSupply: Int
  userCap: Int
  defaultCurrency: String
  profitState: Boolean
}

type LandCount {
  pix: LandTierCount!
  area: LandTierCount!
  zone: LandTierCount!
  sector: LandTierCount!
  domain: LandTierCount!
}

type LandTierCount {
  outlier: Int!
  common: Int!
  uncommon: Int!
  rare: Int!
  legendary: Int!
}

enum LandType {
  pix
  area
  sector
  zone
  domain
}

type LuckyCatRaffle {
  activeRaffles: [RaffleInfo]!
  pastRaffles: [RaffleInfo]!
  upcomingRaffles: [RaffleInfo]!
  myRaffles: [RaffleInfo]!
}

type MCMedia {
  icon: String
  image: String
  video: String
}

type Media {
  animation_url: String
  image: String
}

type MintInfo {
  pix_id: String
  category_id: String
  merkle_index: String
}

type Order {
  orderId: Int
  orderAmount: Int
  creationTime: Int
  amountOfSpeedups: Int
  defaultOrderTime: Int
  speedUpTime: Int
  totalOrderTime: Int
  orderTokenId: Int
  type: String
}

type OrderCost {
  tier: String
  type: String!
  min: Int
  max: Int
  multiplier: Int
}

type OrderData {
  defaultOrderTime: Int!
  variableCosts: [OrderCost]
  fixedCosts: [OrderCost]
  maxOrder: Int
  ixtSpeedupCost: Float!
  astroSpeedupCost: Int
  ixtCooldownSpeedupCost: Float
  cooldownSpeedupTime: Int
  tax: Tax
  weight: [ProbabilityWeights]
}

type PageKey {
  elastic: Int
  chain: String
}

input PageKeyInput {
  elastic: Int
  chain: String
}

type PayType {
  type: String
  balance: Float
}

type PixInfo {
  title: String
  tokenId: String
  tier: PixTier!
  type: LandType!
  staked: Boolean
  minted: Boolean
  mintInfo: MintInfo
  inspectorLink: String
}

type PixResults {
  items: [PixInfo]
  pageKeys: PageKey
}

enum PixTier {
  legendary
  rare
  uncommon
  common
  outlier
}

type Prize {
  prizeAddress: String!
  prizeType: Int!
  items: [PrizeItem]!
  totalPrizes: Int!
}

type PrizeItem {
  id: Int!
  type: String!
  amount: Int!
}

type ProbabilityWeights {
  type: String!
  tier: String
  value: Int!
}

type Query {
  missionControlTokens(credentials: CredentialsInput!, tokenId: String = ""): [Token]
  landmarks(credentials: CredentialsInput!): [Token]
  stakedLandmarks(credentials: CredentialsInput!): [Token]
  landAmount(credentials: CredentialsInput!, chain: String = "polygon"): LandCount
  territoriesAmount(credentials: CredentialsInput!, tier: String!, type: String!, chain: String = "polygon"): Int
  currencies(credentials: CredentialsInput!): [PayType]
  allUniqueTerritories(credentials: CredentialsInput!): [PixInfo]
  uniqueTerritoriesByTierAndSize(credentials: CredentialsInput!, tier: String!, type: String!, chain: String = "polygon"): [PixInfo]
  uniqueLand(credentials: CredentialsInput!, tier: String!, type: String!, pageKeys: PageKeyInput, chain: String = "polygon"): PixResults
  pixByName(credentials: CredentialsInput!, pixId: String!): [PixInfo]
  stakedTerritories(credentials: CredentialsInput!): [PixInfo]
  uniquePixFromWallet(credentials: CredentialsInput!, tier: String!): [PixInfo]
  gravityGradeNFTUri(tokenId: Int!): String
  gravityGradeNFTBalance(credentials: CredentialsInput!): [TokenWithBalance]
  stakedOnTile(credentials: CredentialsInput!, tiles: [TileInput!]!): [StakedNFT]
  oldStakedOnTile(credentials: CredentialsInput!): [StakedNFT]
  searchPixId(credentials: CredentialsInput!, pixId: String!, chain: String = "polygon"): [PixInfo]
  luckyCatRaffleInfo(credentials: CredentialsInput!): LuckyCatRaffle
  unclaimedFacilityOrders(credentials: CredentialsInput!): [Order]
  globalWasteSystemOrderInfo(credentials: CredentialsInput!): [Order]
  eternalLabsOrderInfo(credentials: CredentialsInput!): [Order]
  newlandsOrderInfo(credentials: CredentialsInput!): [Order]
  facilityUpgradeOrderInfo(credentials: CredentialsInput!): [Order]
  globalWasteSystemOrderCosts: OrderData
  eternalLabsOrderCosts: OrderData
  newlandsOrderCosts: OrderData
  facilityUpgradeOrderCosts: OrderData
  isEligible(credentials: CredentialsInput!, packId: Int!): Boolean
  ggSaleInfo(saleId: Int): GravityGradeSaleInfo
  wasteNonce(credentials: CredentialsInput!): Int
  oldWasteNonce(credentials: CredentialsInput!): Int
  ethNFTs(credentials: CredentialsInput!): [Token]
  stakedMCNFTs(credentials: CredentialsInput!): [StakedMCNFTInfo]
  stakedGenesisNFTs(credentials: CredentialsInput!): [StakedMCNFTInfo]
  stakedGenesisNFTsEth(credentials: CredentialsInput!): [StakedMCNFTInfo]
  relayerFee(credentials: CredentialsInput!): String
  baseLevelCapacities(level: Int!): [CorporationCapacity]
  playerBaseLevel(credentials: CredentialsInput!): Int
  rover(credentials: CredentialsInput!): [Token]
  avatarNFT(credentials: CredentialsInput!): [Token]
  badgeNFT(credentials: CredentialsInput!): [Token]
  tokenInfo(tokenIds: [Int!]!, contractAddress: String!): [Token]
  burnedAvatars(credentials: CredentialsInput!, corporation: String!): Boolean
  cooldownFacilityUpgrade(credentials: CredentialsInput!): Int
}

type RaffleInfo {
  id: Int
  dailyTickets: DailyTickets!
  winnings: [Winnings]
  prize: Prize!
  entriesByWallet: Int
  totalEntries: Int
  isDrawn: Boolean
}

type RawMetadata {
  name: String
  description: String
  image: String
  external_url: String
  animation_url: String
  attributes: [Attribute]
}

type Resource {
  tokenId: Int
  balance: Int
}

type StakedMCNFTInfo {
  tokenId: Int!
  amount: Int!
  lockedAt: Int!
}

type StakedNFT {
  tiles: Tile
  base: StakedPixInfo
  top: [StakedTopAssetInfo]
  isRented: Boolean!
  rentalToken: String!
  rentPrice: String
}

type StakedPixInfo {
  stakedAddress: String
  land: PixInfo
  nonce: Int
  resource: Resource
}

type StakedTopAssetInfo {
  stakedAddress: String
  token: TokenInfo
  nonce: Int
  timeLeft: Int
  resource: Resource
  index: Int
}

type Tax {
  value: Int
  basisPoints: Int
}

type Territory {
  name: String
  description: String
  image: String
  attributes: [Attribute]
  animation_url: String
}

type Tile {
  q: Int!
  r: Int!
  s: Int!
}

type TileInfo {
  tiles: Tile
  amount: Int
  tokenId: Int
  tokenAddress: String
}

input TileInput {
  q: Int
  r: Int
  s: Int
}

type Token {
  contract: String
  tokenType: String
  name: String!
  tokenId: String!
  description: String!
  external_url: String
  media: Media!
  mcMedia: MCMedia
  attributes: [Attribute]!
  balance: Int
  totalShares: String
  staked: Boolean
}

type TokenInfo {
  title: String
  tokenId: String!
  tier: String!
  type: String!
  status: String
}

type TokenUri {
  raw: String
  gateway: String
}

type TokenWithBalance {
  tokenId: Int
  tier: String
  type: String
  balance: Int
}

type Winnings {
  walletAddress: String!
  enteredWith: Int!
  amount: Int!
  prizeIds: [Int]!
  hasClaimed: Boolean!
}

