directive @cacheControl(
  maxAge: Int
  scope: CacheControlScope
  inheritMaxAge: Boolean
) on FIELD_DEFINITION | OBJECT | INTERFACE | UNION

"""
Exposes a URL that specifies the behavior of this scalar.
"""
directive @specifiedBy(
  """
  The URL that specifies the behavior of this scalar.
  """
  url: String!
) on SCALAR

type AssetConverterRecipe {
  recipeId: Int!
  recipe: [Token]!
  outcome: [Token]!
}

type Attribute {
  value: String
  traitType: String
}

enum CacheControlScope {
  PUBLIC
  PRIVATE
}

type CatRaffTicketInfo {
  address: String
  week: Int
  totalTickets: Int
  winAmount: Int
  userEnteredTicket: Int
}

type Contract {
  address: String
}

type CorporationCapacity {
  name: String!
  capacity: Int!
}

input CredentialsInput {
  playerId: Int
  walletAddress: String
}

type DailyTickets {
  ticket: Token!
  minEntriesPerWallet: Int!
  maxEntriesPerWallet: Int!
  maxTotalEntries: Int!
  startTime: Int!
  duration: Int!
}

type EnergyStakedAt {
  amount: Int
  timestamp: Int
}

type GenericStoreSaleInfo {
  saleId: Int
  token: Token!
  totalSupply: Float!
  price: Int!
  userCap: Float!
  sold: Int
  inStock: Boolean!
  unique: Boolean!
  displayPrice: String!
  paymentMethod: [String]
  amount: Int!
  supplyText: String
}

type GovernanceData {
  period: Float
  votingPower: Float
  deligatedPower: Float
  votingPowerStaked: Float
  deligatedPowerStaked: Float
}

type LandCount {
  pix: LandTierCount!
  area: LandTierCount!
  zone: LandTierCount!
  sector: LandTierCount!
  domain: LandTierCount!
}

enum LandmarkSort {
  sharesLowToHigh
  sharesHighToLow
  ownersLowToHigh
  ownersHighToLow
  earningLowToHigh
  earningHighToLow
  starsLowToHigh
  starsHighToLow
}

enum LandmarkTier {
  all
  legendary
  rare
  uncommon
  common
  outlier
}

type LandTierCount {
  outlier: Int!
  common: Int!
  uncommon: Int!
  rare: Int!
  legendary: Int!
}

enum LandType {
  pix
  area
  sector
  zone
  domain
}

type LuckyCatRaffle {
  activeRaffles: [RaffleInfo]!
  pastRaffles: [RaffleInfo]!
  upcomingRaffles: [RaffleInfo]!
  myRaffles: [RaffleInfo]!
}

type Media {
  animation_url: String
  image: String
  mcIcon: String
  mcImage: String
  mcVideo: String
  alchemyThumbnail: String
  alchemy: String
}

type MintInfo {
  pix_id: String
  category_id: String
  merkle_index: String
}

type Order {
  orderId: Int
  orderAmount: Int
  creationTime: Int
  amountOfSpeedups: Int
  defaultOrderTime: Int
  speedUpTime: Int
  totalOrderTime: Int
  orderTokenId: Int
  type: String
}

type OrderCost {
  token: Token
  min: Int
  max: Int
  multiplier: Int
}

type OrderData {
  defaultOrderTime: Int!
  variableCosts: [OrderCost]
  fixedCosts: [OrderCost]
  maxOrder: Int
  ixtSpeedupCost: Float!
  astroSpeedupCost: Int
  ixtCooldownSpeedupCost: Float
  cooldownSpeedupTime: Int
  tax: Tax
  weight: [ProbabilityWeights]
  boostedWeight: [ProbabilityWeights]
}

type PageKey {
  elastic: Int
  chain: String
}

input PageKeyInput {
  elastic: Int
  chain: String
}

type PayType {
  type: String
  balance: Float
}

type PixResults {
  items: [Token]
  pageKeys: PageKey
}

enum PixTier {
  legendary
  rare
  uncommon
  common
  outlier
}

type PolygonScanTransactions {
  blockNumber: String
  timeStamp: String
  hash: String
  nonce: String
  blockHash: String
  from: String
  contractAddress: String
  to: String
  value: String
  tokenName: String
  tokenSymbol: String
  tokenDecimal: String
  transactionIndex: String
  gas: String
  gasPrice: String
  gasUsed: String
  cumulativeGasUsed: String
  input: String
  confirmations: String
}

type Prize {
  prizeAddress: String!
  prizeType: Int!
  items: [PrizeItem]!
  totalPrizes: Int!
}

type PrizeItem {
  token: Token!
  amount: Int!
}

type ProbabilityWeights {
  token: Token
  value: Int!
}

type Query {
  missionControlTokens(credentials: CredentialsInput): [Token]
  landmarks(credentials: CredentialsInput): [Token]
  stakedLandmarks(credentials: CredentialsInput): [Token]
  landAmount(credentials: CredentialsInput!, chain: String = "polygon"): [Token]
  territoriesAmount(
    credentials: CredentialsInput!
    tier: String!
    type: String!
    chain: String = "polygon"
  ): Int
  currencies(credentials: CredentialsInput): [Token]
  allUniqueTerritories(credentials: CredentialsInput!): [Token]
  uniqueLand(
    credentials: CredentialsInput!
    tier: String!
    type: String!
    pageKeys: PageKeyInput
    chain: String = "polygon"
  ): PixResults
  pixByName(credentials: CredentialsInput!, pixId: String!): [Token]
  stakedTerritories(credentials: CredentialsInput): [Token]
  uniquePixFromWallet(credentials: CredentialsInput, tier: String!): [Token]
  gravityGradeNFTUri(tokenId: Int!): String
  gravityGradeNFTBalance(credentials: CredentialsInput): [Token]
  gravityGradePackContent(token: TokenInput!): [TokenProbability]
  stakedOnTile(credentials: CredentialsInput, tiles: [TileInput!]!): [StakedNFT]
  oldStakedOnTile(credentials: CredentialsInput): [StakedNFT]
  searchPixId(
    credentials: CredentialsInput
    pixId: String!
    chain: String = "polygon"
  ): [Token]
  luckyCatRaffleInfo(credentials: CredentialsInput): LuckyCatRaffle
  unclaimedFacilityOrders(credentials: CredentialsInput): [Order]
  globalWasteSystemOrderInfo(credentials: CredentialsInput): [Order]
  eternalLabsOrderInfo(credentials: CredentialsInput): [Order]
  newlandsOrderInfo(credentials: CredentialsInput): [Order]
  facilityUpgradeOrderInfo(credentials: CredentialsInput): [Order]
  metamodFusionOrderInfo(credentials: CredentialsInput): [Order]
  globalWasteSystemOrderCosts: OrderData
  eternalLabsOrderCosts: OrderData
  newlandsOrderCosts: OrderData
  facilityUpgradeOrderCosts: OrderData
  metamodFusionOrderCosts: OrderData
  isEligible(credentials: CredentialsInput, packId: Int!): Boolean
  saleInfo(shopId: String!): [GenericStoreSaleInfo]
  wasteNonce(credentials: CredentialsInput): Int
  oldWasteNonce(credentials: CredentialsInput): Int
  ethNFTs(credentials: CredentialsInput): [Token]
  stakedMCNFTs(credentials: CredentialsInput): [StakedMCNFTInfo]
  stakedGenesisNFTs(credentials: CredentialsInput): [StakedMCNFTInfo]
  stakedGenesisNFTsEth(credentials: CredentialsInput): [StakedMCNFTInfo]
  relayerFee(credentials: CredentialsInput): String
  baseLevelCapacities(level: Int!): [CorporationCapacity]
  playerBaseLevel(credentials: CredentialsInput): Int
  rover(credentials: CredentialsInput): [Token]
  avatarNFT(credentials: CredentialsInput): [Token]
  badgeNFT(credentials: CredentialsInput): [Token]
  geoLotteryNFT(credentials: CredentialsInput): [Token]
  tokenInfo(tokenIds: [Int!]!, contractAddress: String!): [Token]
  tokenInfoTypeTier(
    tokens: [TokenInput!]!
    contractAddress: String!
    chain: String = "polygon"
  ): [Token]
  burnedAvatars(credentials: CredentialsInput, corporation: String!): Boolean
  cooldownFacilityUpgrade(credentials: CredentialsInput): Int
  assetConverterRecipes: [AssetConverterRecipe]
  stakingData(credentials: CredentialsInput, id: StakingId!): StakingData
  stakingsData(credentials: CredentialsInput, ids: [StakingId]): [StakingData]
  allLandmarks(
    page: Int
    searchWord: String
    filter: LandmarkTier
    order: LandmarkSort
  ): [Token]
  catRaffAccounts(skip: Int): [CatRaffTicketInfo]
  catRaffWeekly(credentials: CredentialsInput): [CatRaffTicketInfo]
  catRaffPastPrizes(skip: Int): [CatRaffTicketInfo]
  governance(credentials: CredentialsInput): GovernanceData
}

type RaffleInfo {
  id: Int
  dailyTickets: DailyTickets!
  winnings: [Winnings]
  prize: Prize!
  entriesByWallet: Int
  totalEntries: Int
  isDrawn: Boolean
  hasClaimed: Boolean
  isWinner: Boolean
}

type RawMetadata {
  name: String
  description: String
  image: String
  external_url: String
  animation_url: String
  attributes: [Attribute]
}

type StakedMCNFTInfo {
  token: Token!
  amount: Int!
  lockedAt: Int!
}

type StakedNFT {
  tiles: Tile
  base: StakedPixInfo
  top: [StakedTopAssetInfo]
  isRented: Boolean!
  rentalToken: String!
  rentPrice: String
  tileName: String
  ring: String
}

type StakedPixInfo {
  stakedAddress: String
  land: Token
  nonce: Int
  resource: Token
}

type StakedTopAssetInfo {
  stakedAddress: String
  token: Token
  nonce: Int
  timeLeft: Int
  resource: Token
  index: Int
  resourceAmount: Int
  progress: Float
  finishTime: String
  cap: Int
}

type StakingData {
  epochEndtime: Float
  currentEpochPool: Float
  nextEpochPool: Float
  totalStakedAmount: Float
  lockPeriod: Float
  userSpecificStakingData: UserSpecificStakingData
  prizeAmount: Int
  transactions: [PolygonScanTransactions]
  stakingItems: [StakingItem]!
}

enum StakingId {
  ixtOneMonth
  ixtThreeMonths
  ixtSixMonths
  ixtTwelveMonths
  landmark
  metashare
  energy
  energyAmelia
  territories
  territoriesUser
  catRaff
  lpUSDT
  lpMATIC
}

type StakingItem {
  token: Token!
  rewardPerDay: Float
  rewardPerThirtyDays: Float
  rewardRate: Float
  totalStaked: Float
  userStakingData: TokenSpecificUserStakingData
  odds: Float
}

input StakingTypes {
  type: PixTier
}

type Tax {
  value: Int
  basisPoints: Int
}

type Territory {
  name: String
  description: String
  image: String
  attributes: [Attribute]
  animation_url: String
}

type Tile {
  q: Int!
  r: Int!
  s: Int!
}

type TileInfo {
  tiles: Tile
  amount: Int
  tokenId: Int
  tokenAddress: String
}

input TileInput {
  q: Int
  r: Int
  s: Int
}

type Token {
  contract: String
  tokenType: String
  external_url: String
  tokenId: Int
  balance: Float
  totalSupply: Int
  tokenInfo: TokenInfo
  media: Media
  network: String
  mintInfo: MintInfo
}

type TokenInfo {
  title: String
  tier: String
  type: String!
  status: String
  description: String
  attributes: [Attribute]
  staked: Boolean
  minted: Boolean
  inspectorLink: String
  level: Int
  openable: Boolean
}

input TokenInput {
  type: String!
  tier: String
}

type TokenProbability {
  token: Token!
  probability: Float
}

type TokenSpecificUserStakingData {
  amountStaked: Float
  totalReward: Float
  userRewardPerDay: Float
  userRewardPerThirtyDays: Float
  balanceOfToken: Float
  stakedAt: Int
  energyStakedAt: [EnergyStakedAt]
}

type TokenUri {
  raw: String
  gateway: String
}

type UserSpecificStakingData {
  totalUserReward: Float
  totalUserRewardPerDay: Float
  totalUserRewardPerThirtyDays: Float
}

type Winnings {
  walletAddress: String!
  enteredWith: Int!
  amount: Int!
  prizeIds: [Int]!
}
